<html>
<head>
<title>
CSocket - Socket Library
</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>

<body bgcolor="#ffffff"> 
<table width="100%">
  <tr>
    <td width="40%" align="left" valign="center">
      <a href="http://carrierlabs.com/projects/sockets">
      CSocket project page
      </a>
    </td>
    <td>
      <a href="FAQ">FAQ</a>
    </td>
    <td width="40%" align="right" valign="center">
      <a href="http://csocket.carrierlabs.com">CSocket home page</a>
    </td>
  </tr>
</table>

<hr>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="simple_socket_cookbook">Simple Socket Cookbook</a></h1>Here is a short cookbook to help you get started.<h2><a class="anchor" name="socket_overview">
Simple Socket Class Overview</a></h2>
Network communications via sockets can be abstracted into two categories of functionality; the active socket and the passive socket. The active socket object initiates a connection with a known host, whereas the passive socket object waits (or listens) for inbound requests for communication. The functionality of both objects is identical as far as sending and receiving data. This library makes distinction between the two objects because the operations for constructing and destructing the two are different. This library is different from other socket libraries which define TCP sockets, UDP sockets, HTTP sockets, etc. The reason is the operations required for TCP, UDP, and RAW network communication is identical from a logical stand point. Thus a program could initially be written employing TCP streams, and then at some future point it could be discovered that UDP datagrams would satisify the solution. Changing between the two transport protocols would only require changing how the object is instantiated. The remaining code would require no changes.<p>
This library avoids abstractions like HTTP socket, or SMTP socket, soley because this type of object mixes the application and the transport layer. These types of abstractions can be created using this library as a base class.<p>
The simple socket library is comprised of two class which can be used to represent all socket communications.<p>
<ul>
<li><a class="el" href="">Active Socket Class </a></li><li><a class="el" href="">Passive Socket Class </a></li></ul>
<h2><a class="anchor" name="CActiveSocket">
Active Socket Class</a></h2>
<h2><a class="anchor" name="CPassiveSocket">
Passive Socket Class</a></h2>
<h2><a class="anchor" name="simple_acitve_socket">
Simple Active Socket</a></h2>
As mentioned previously the active socket (CActiveSocket) is used to initiate a connections with a server on some known port. So you want to connect to an existing server...<p>
How do you do it?<p>
There are many ways using the existing Berkley Socket API, but the goal of this class is to remove the many calls and man page lookups and replace them with clear, concise set of methods which allow a developer to focus on the logic of network programming.<p>
The following code will connect to a DAYTIME server on port 13, query for the current time, and close the socket.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include "ActiveSocket.h"</span>       <span class="comment">// Include header for active socket object definition</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
    CActiveSocket socket;       <span class="comment">// Instantiate active socket object (defaults to TCP).</span>
    <span class="keywordtype">char</span>          time[50];

    memset(&amp;time, 0, 50);

    <span class="comment">//--------------------------------------------------------------------------</span>
    <span class="comment">// Initialize our socket object </span>
    <span class="comment">//--------------------------------------------------------------------------</span>
    socket.Initialize();

    <span class="comment">//--------------------------------------------------------------------------</span>
    <span class="comment">// Create a connection to the time server so that data can be sent</span>
    <span class="comment">// and received.</span>
    <span class="comment">//--------------------------------------------------------------------------</span>
    <span class="keywordflow">if</span> (socket.Open((<span class="keyword">const</span> UINT8 *)<span class="stringliteral">"time-C.timefreq.bldrdoc.gov"</span>, 13))
    {
        <span class="comment">//----------------------------------------------------------------------</span>
        <span class="comment">// Send a requtest the server requesting the current time.</span>
        <span class="comment">//----------------------------------------------------------------------</span>
        <span class="keywordflow">if</span> (socket.Send((<span class="keyword">const</span> UINT8 *)<span class="stringliteral">"\n"</span>, 1))
        {
            <span class="comment">//----------------------------------------------------------------------</span>
            <span class="comment">// Receive response from the server.</span>
            <span class="comment">//----------------------------------------------------------------------</span>
            socket.Receive(49);
            memcpy(&amp;time, socket.GetData(), 49);
            printf(<span class="stringliteral">"%s\n"</span>, time);

            <span class="comment">//----------------------------------------------------------------------</span>
            <span class="comment">// Close the connection.</span>
            <span class="comment">//----------------------------------------------------------------------</span>
            socket.Close();
        }
    }


    <span class="keywordflow">return</span> 1;
}
</pre></div><p>
You can see that the amount of code required to an object for network communciation is very small and simple.<h2><a class="anchor" name="simple_passive_socket">
Simple Passive Socket</a></h2>
Now you want to build a server.<p>
How do you do it?<p>
For a practical test lets build an echo server. The server will listen on port 6789 an repsond back with what ever has been sent to the server.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "PassiveSocket.h"</span>

<span class="preprocessor">#define MAX_PACKET 4096 </span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
    CPassiveSocket socket;
    CActiveSocket *pClient = NULL;

    socket.Initialize();
    socket.Listen((<span class="keyword">const</span> UINT8 *)<span class="stringliteral">"127.0.0.1"</span>, 6789);

    <span class="keywordflow">while</span> (<span class="keyword">true</span>)
    {
        <span class="keywordflow">if</span> ((pClient = socket.Accept()) != NULL)
        {
            <span class="keywordflow">if</span> (pClient-&gt;Receive(MAX_PACKET))
            {
                pClient-&gt;Send((<span class="keyword">const</span> UINT8 *)pClient-&gt;GetData(), pClient-&gt;GetBytesReceived());
                pClient-&gt;Close();
            }

            <span class="keyword">delete</span> pClient;
        }
    }
    socket.Close();
    <span class="keywordflow">return</span> 1;
}
</pre></div><p>
You can see that the amount of code used to do this is very small, very easy to read, and very flexible.<h2><a class="anchor" name="fixture">
Fixture</a></h2>
A fixture is a known set of objects that serves as a base for a set of test cases. Fixtures come in very handy when you are testing as you develop.<p>
Let's try out this style of development and learn about fixtures along the away. Suppose that we are really developing a complex number class. Let's start by defining a empty class named Complex.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Complex {};
</pre></div><p>
Now create an instance of ComplexNumberTest above, compile the code and see what happens. The first thing we notice is a few compiler errors. The test uses <code>operator ==</code>, but it is not defined. Let's fix that.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> Complex &amp;a, <span class="keyword">const</span> Complex &amp;b) 
{ 
  <span class="keywordflow">return</span> <span class="keyword">true</span>; 
}
</pre></div><p>
Now compile the test, and run it. This time it compiles but the test fails. We need a bit more to get an <code>operator ==</code>working correctly, so we revisit the code.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Complex { 
  <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator ==(<span class="keyword">const</span> Complex&amp; a, <span class="keyword">const</span> Complex&amp; b);
  <span class="keywordtype">double</span> real, imaginary;
<span class="keyword">public</span>:
  Complex( <span class="keywordtype">double</span> r, <span class="keywordtype">double</span> i = 0 ) 
    : real(r)
        , imaginary(i) 
  {
  }
};

<span class="keywordtype">bool</span> operator ==( <span class="keyword">const</span> Complex &amp;a, <span class="keyword">const</span> Complex &amp;b )
{ 
  <span class="keywordflow">return</span> a.real == b.real  &amp;&amp;  a.imaginary == b.imaginary; 
}
</pre></div><p>
If we compile now and run our test it will pass.<p>
Now we are ready to add new operations and new tests. At this point a fixture would be handy. We would probably be better off when doing our tests if we decided to instantiate three or four complex numbers and reuse them across our tests.<p>
Here is how we do it:<ul>
<li>Add member variables for each part of the <a class="el" href="">fixture </a></li><li>Override <a class="el" href="">tearDown() </a> to release any permanent resources you allocated in <a class="el" href="">setUp() </a></li></ul>
<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>ComplexNumberTest : <span class="keyword">public</span> CppUnit::TestFixture {
<span class="keyword">private</span>:
  Complex *m_10_1, *m_1_1, *m_11_2;
<span class="keyword">public</span>:
  <span class="keywordtype">void</span> setUp()
  {
    m_10_1 = <span class="keyword">new</span> Complex( 10, 1 );
    m_1_1 = <span class="keyword">new</span> Complex( 1, 1 );
    m_11_2 = <span class="keyword">new</span> Complex( 11, 2 );  
  }

  <span class="keywordtype">void</span> tearDown() 
  {
    <span class="keyword">delete</span> m_10_1;
    <span class="keyword">delete</span> m_1_1;
    <span class="keyword">delete</span> m_11_2;
  }
};
</pre></div><p>
Once we have this fixture, we can add the complex addition test case any any others that we need over the course of our development.<h2><a class="anchor" name="test_case">
Test Case</a></h2>
How do you write and invoke individual tests using a fixture?<p>
There are two steps to this process:<ul>
<li>Write the test case as a method in the fixture class</li><li>Create a TestCaller which runs that particular method</li></ul>
<p>
Here is our test case class with a few extra case methods:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>ComplexNumberTest : <span class="keyword">public</span> CppUnit::TestFixture  {
<span class="keyword">private</span>:
  Complex *m_10_1, *m_1_1, *m_11_2;
<span class="keyword">public</span>:
  <span class="keywordtype">void</span> setUp()
  {
    m_10_1 = <span class="keyword">new</span> Complex( 10, 1 );
    m_1_1 = <span class="keyword">new</span> Complex( 1, 1 );
    m_11_2 = <span class="keyword">new</span> Complex( 11, 2 );  
  }

  <span class="keywordtype">void</span> tearDown() 
  {
    <span class="keyword">delete</span> m_10_1;
    <span class="keyword">delete</span> m_1_1;
    <span class="keyword">delete</span> m_11_2;
  }

  <span class="keywordtype">void</span> testEquality()
  {
    CPPUNIT_ASSERT( *m_10_1 == *m_10_1 );
    CPPUNIT_ASSERT( !(*m_10_1 == *m_11_2) );
  }

  <span class="keywordtype">void</span> testAddition()
  {
    CPPUNIT_ASSERT( *m_10_1 + *m_1_1 == *m_11_2 );
  }
};
</pre></div><p>
One may create and run instances for each test case like this:<p>
<div class="fragment"><pre class="fragment">CppUnit::TestCaller&lt;ComplexNumberTest&gt; test( <span class="stringliteral">"testEquality"</span>, 
                                             &amp;ComplexNumberTest::testEquality );
CppUnit::TestResult result;
test.run( &amp;result );
</pre></div><p>
The second argument to the test caller constructor is the address of a method on ComplexNumberTest. When the test caller is run, that specific method will be run. This is not a useful thing to do, however, as no diagnostics will be displayed. One will normally use a <a class="el" href="group__ExecutingTest.html">TestRunner </a> (see below) to display the results.<p>
Once you have several tests, organize them into a suite.<h2><a class="anchor" name="suite">
Suite</a></h2>
How do you set up your tests so that you can run them all at once?<p>
CppUnit provides a <a class="el" href="">TestSuite </a> class that runs any number of TestCases together.<p>
We saw, above, how to run a single test case.<p>
To create a suite of two or more tests, you do the following:<p>
<div class="fragment"><pre class="fragment">CppUnit::TestSuite suite;
CppUnit::TestResult result;
suite.addTest( <span class="keyword">new</span> CppUnit::TestCaller&lt;ComplexNumberTest&gt;(
                       <span class="stringliteral">"testEquality"</span>, 
                       &amp;ComplexNumberTest::testEquality ) );
suite.addTest( <span class="keyword">new</span> CppUnit::TestCaller&lt;ComplexNumberTest&gt;(
                       <span class="stringliteral">"testAddition"</span>, 
                       &amp;ComplexNumberTest::testAddition ) );
suite.run( &amp;result );
</pre></div><p>
<a class="el" href="">TestSuites </a> don't only have to contain callers for TestCases. They can contain any object that implements the <a class="el" href="">Test </a> interface. For example, you can create a <a class="el" href="">TestSuite </a> in your code and I can create one in mine, and we can run them together by creating a <a class="el" href="">TestSuite </a> that contains both:<p>
<div class="fragment"><pre class="fragment">CppUnit::TestSuite suite;
CppUnit::TestResult result;
suite.addTest( ComplexNumberTest::suite() );
suite.addTest( SurrealNumberTest::suite() );
suite.run( &amp;result );
</pre></div><h2><a class="anchor" name="test_runner">
TestRunner</a></h2>
How do you run your tests and collect their results?<p>
Once you have a test suite, you'll want to run it. CppUnit provides tools to define the suite to be run and to display its results. You make your suite accessible to a <a class="el" href="group__ExecutingTest.html">TestRunner </a> program with a static method <em>suite</em> that returns a test suite.<p>
For example, to make a ComplexNumberTest suite available to a <a class="el" href="group__ExecutingTest.html">TestRunner </a>, add the following code to ComplexNumberTest:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">public</span>: 
  <span class="keyword">static</span> CppUnit::Test *suite()
  {
    CppUnit::TestSuite *suiteOfTests = <span class="keyword">new</span> CppUnit::TestSuite( <span class="stringliteral">"ComplexNumberTest"</span> );
    suiteOfTests-&gt;addTest( <span class="keyword">new</span> CppUnit::TestCaller&lt;ComplexNumberTest&gt;( 
                                   <span class="stringliteral">"testEquality"</span>, 
                                   &amp;ComplexNumberTest::testEquality ) );
    suiteOfTests-&gt;addTest( <span class="keyword">new</span> CppUnit::TestCaller&lt;ComplexNumberTest&gt;(
                                   <span class="stringliteral">"testAddition"</span>,
                                   &amp;ComplexNumberTest::testAddition ) );
    <span class="keywordflow">return</span> suiteOfTests;
  }
</pre></div><p>
<a class="anchor" name="test_runner_code"></a> To use the text version, include the header files for the tests in Main.cpp:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;cppunit/ui/text/TestRunner.h&gt;</span>
<span class="preprocessor">#include "ExampleTestCase.h"</span>
<span class="preprocessor">#include "ComplexNumberTest.h"</span>
</pre></div><p>
And add a call to <a class="el" href="">addTest(CppUnit::Test *) </a> in the <code>main()</code> function:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  CppUnit::TextUi::TestRunner runner;
  runner.addTest( ExampleTestCase::suite() );
  runner.addTest( ComplexNumberTest::suite() );
  runner.run();
  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The <a class="el" href="group__ExecutingTest.html">TestRunner </a> will run the tests. If all the tests pass, you'll get an informative message. If any fail, you'll get the following information:<p>
<ul>
<li>The name of the test case that failed</li><li>The name of the source file that contains the test</li><li>The line number where the failure occurred</li><li>All of the text inside the call to CPPUNIT_ASSERT() which detected the failure</li></ul>
<p>
CppUnit distinguishes between <em>failures</em> and <em>errors</em>. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like division by zero and other exceptions thrown by the C++ runtime or your code.<h2><a class="anchor" name="helper_macros">
Helper Macros</a></h2>
As you might have noticed, implementing the fixture static <code>suite()</code> method is a repetitive and error prone task. A WritingTestFixture set of macros have been created to automatically implements the static <code>suite()</code> method.<p>
The following code is a rewrite of ComplexNumberTest using those macros:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;cppunit/extensions/HelperMacros.h&gt;</span>

<span class="keyword">class </span>ComplexNumberTest : <span class="keyword">public</span> CppUnit::TestFixture  {
</pre></div> First, we declare the suite, passing the class name to the macro: <div class="fragment"><pre class="fragment">CPPUNIT_TEST_SUITE( ComplexNumberTest );
</pre></div> The suite created by the static <code>suite()</code> method is named after the class name. Then, we declare each test case of the fixture: <div class="fragment"><pre class="fragment">CPPUNIT_TEST( testEquality );
CPPUNIT_TEST( testAddition );
</pre></div> Finally, we end the suite declaration: <div class="fragment"><pre class="fragment">CPPUNIT_TEST_SUITE_END();
</pre></div> At this point, a method with the following signature has been implemented: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> CppUnit::TestSuite *suite();
</pre></div> The rest of the fixture is left unchanged: <div class="fragment"><pre class="fragment"><span class="keyword">private</span>:
  Complex *m_10_1, *m_1_1, *m_11_2;
<span class="keyword">public</span>:
  <span class="keywordtype">void</span> setUp()
  {
    m_10_1 = <span class="keyword">new</span> Complex( 10, 1 );
    m_1_1 = <span class="keyword">new</span> Complex( 1, 1 );
    m_11_2 = <span class="keyword">new</span> Complex( 11, 2 );  
  }

  <span class="keywordtype">void</span> tearDown() 
  {
    <span class="keyword">delete</span> m_10_1;
    <span class="keyword">delete</span> m_1_1;
    <span class="keyword">delete</span> m_11_2;
  }

  <span class="keywordtype">void</span> testEquality()
  {
    CPPUNIT_ASSERT( *m_10_1 == *m_10_1 );
    CPPUNIT_ASSERT( !(*m_10_1 == *m_11_2) );
  }

  <span class="keywordtype">void</span> testAddition()
  {
    CPPUNIT_ASSERT( *m_10_1 + *m_1_1 == *m_11_2 );
  }
};
</pre></div><p>
The name of the <a class="el" href="">TestCaller </a> added to the suite are a composition of the fixture name and the method name.<p>
In the present case, the names would be: "ComplexNumberTest.testEquality" and "ComplexNumberTest.testAddition".<p>
The <a class="el" href="">helper macros </a> help you write comon assertion. For example, to check that ComplexNumber throws a MathException when dividing a number by 0:<ul>
<li>add the test to the suite using CPPUNIT_TEST_EXCEPTION, specifying the expected exception type.</li><li>write the test case method</li></ul>
<p>
<div class="fragment"><pre class="fragment">CPPUNIT_TEST_SUITE( ComplexNumberTest );
<span class="comment">// [...]</span>
CPPUNIT_TEST_EXCEPTION( testDivideByZeroThrows, MathException );
CPPUNIT_TEST_SUITE_END();

<span class="comment">// [...]</span>

  <span class="keywordtype">void</span> testDivideByZeroThrows()
  {
    <span class="comment">// The following line should throw a MathException.</span>
    *m_10_1 / ComplexNumber(0);
  }
</pre></div><p>
If the expected exception is not thrown, then a assertion failure is reported.<h2><a class="anchor" name="test_factory_registry">
TestFactoryRegistry</a></h2>
The TestFactoryRegistry was created to solve two pitfalls:<ul>
<li>forgetting to add your fixture suite to the test runner (since it is in another file, it is easy to forget)</li><li>compilation bottleneck caused by the inclusion of all test case headers (see <a class="el" href="simple_socket_cookbook.html#test_runner_code">previous example</a>)</li></ul>
<p>
The TestFactoryRegistry is a place where suites can be registered at initialization time.<p>
To register the ComplexNumber suite, in the .cpp file, you add:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;cppunit/extensions/HelperMacros.h&gt;</span>

CPPUNIT_TEST_SUITE_REGISTRATION( ComplexNumberTest );
</pre></div><p>
Behind the scene, a static variable type of <a class="el" href="">AutoRegisterSuite </a> is declared. On construction, it will <a class="el" href="">register </a> a <a class="el" href="">TestSuiteFactory </a> into the <a class="el" href="">TestFactoryRegistry </a>. The <a class="el" href="">TestSuiteFactory </a> returns the <a class="el" href="">TestSuite </a> returned by ComplexNumber::suite().<p>
To run the tests, using the text test runner, we don't need to include the fixture anymore:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;cppunit/extensions/TestFactoryRegistry.h&gt;</span>
<span class="preprocessor">#include &lt;cppunit/ui/text/TestRunner.h&gt;</span>

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  CppUnit::TextUi::TestRunner runner;
</pre></div> First, we retreive the instance of the <a class="el" href="">TestFactoryRegistry </a>: <div class="fragment"><pre class="fragment">  CppUnit::TestFactoryRegistry &amp;registry = CppUnit::TestFactoryRegistry::getRegistry();
</pre></div> Then, we obtain and add a new <a class="el" href="">TestSuite </a> created by the <a class="el" href="">TestFactoryRegistry </a> that contains all the test suite registered using CPPUNIT_TEST_SUITE_REGISTRATION(). <div class="fragment"><pre class="fragment">  runner.addTest( registry.makeTest() );
  runner.run();
  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" name="post_build_check">
Post-build check</a></h2>
Well, now that we have our unit tests running, how about integrating unit testing to our build process ?<p>
To do that, the application must returns a value different than 0 to indicate that there was an error.<p>
<a class="el" href="">TestRunner::run() </a> returns a boolean indicating if the run was successful.<p>
Updating our main programm, we obtains: <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;cppunit/extensions/TestFactoryRegistry.h&gt;</span>
<span class="preprocessor">#include &lt;cppunit/ui/text/TestRunner.h&gt;</span>

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  CppUnit::TextUi::TestRunner runner;
  CppUnit::TestFactoryRegistry &amp;registry = CppUnit::TestFactoryRegistry::getRegistry();
  runner.addTest( registry.makeTest() );
  <span class="keywordtype">bool</span> wasSuccessful = runner.run( <span class="stringliteral">""</span>, <span class="keyword">false</span> );
  <span class="keywordflow">return</span> wasSuccessful;
}
</pre></div><p>
Now, you need to run your application after compilation.<p>
With Visual C++, this is done in <em>Project Settings/Post-Build step</em>, by adding the following command: <code></code>. It is expanded to the application executable path. Look up the project <code>examples/cppunittest/CppUnitTestMain.dsp</code> which use that technic.<p>
Original version by Michael Feathers. Doxygen conversion and update by Baptiste Lepilleur. <hr>
<table width="100%">
  <tr>
    <td width="10%" align="left" valign="center">
      <a href="http://carrierlabs.com"> 
      <img
      src="http://sourceforge.net/sflogo.php?group_id=11795"
      width="88" height="31" border="0" alt="SourceForge Logo"></a>
    </td>
    <td width="20%" align="left" valign="center">
      hosts this site.
    </td>
    <td>
    </td>
    <td align="right" valign="center">
      Send comments to:<br>
      <a href="mailto:mark@carrierlabs.com">CarrierLabs Developers</a>
    </td>
  </tr>
</table>

</body> 
</html>
